<html lang="en">
  <head>
    <title>Single Page GPU SDF Ray Marcher - Ben Coleman</title>
  </head>
  <body style="margin: 0">
    <canvas style="width: 100%" width="640" height="480"></canvas>
    <script id="vs" type="x-shader/x-vertex">
      #version 300 es
      in vec4 position;
      void main() { gl_Position = position; }
    </script>
    <script id="fs" type="x-shader/x-fragment">
      #version 300 es
      precision highp float;
      uniform vec2 u_resolution; uniform float u_time;
      out vec4 fragColor;

      float sdfSphere(vec3 p, float s) { return length(p) - s; }
      float sdfCube(vec3 p, float s) {
        vec3 d = abs(p) - vec3(s);
        return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
      }
      float smoothMin(float a, float b, float k) {
        float h = max(k - abs(a - b), 0.0) / k;
        return min(a, b) - h * h * k * 0.25;
      }

      float map(vec3 p) {
        vec3 p1 = p; vec3 p2 = p;
        p1.x += sin(u_time * 1.85) * 1.3;
        p2.y += cos(u_time * 1.33) * 1.2;
        float d1 = sdfSphere(p1 - vec3(-1.0, 0.0, 0.0), 1.0);
        float d2 = sdfSphere(p2 - vec3(1.0, 0.0, 0.0), 1.3);
        float d3 = sdfCube(p - vec3(0.0, -1.2, -0.2), 0.7);
        return smoothMin(smoothMin(d1, d2, 0.5), d3, 0.8);
      }

      vec2 marchRay(vec3 ro, vec3 rd) {
        float t = 0.0;
        for (int i = 0; i < 40; i++) {
          float d = map(ro + rd * t);
          if (d < 0.0001) { return vec2(t, 1.0); } // hit
          t += d;
          if (t > 5.0) break;
        }
        return vec2(0.0, 0.0); // miss
      }

      vec3 normal(vec3 p) {
        return normalize(vec3(
          map(p + vec3(0.001, 0.0, 0.0)) - map(p - vec3(0.001, 0.0, 0.0)),
          map(p + vec3(0.0, 0.001, 0.0)) - map(p - vec3(0.0, 0.001, 0.0)),
          map(p + vec3(0.0, 0.0, 0.001)) - map(p - vec3(0.0, 0.0, 0.001))
        ));
      }

      void main() {
        const vec3 sphereCol = vec3(1.0, 0.45, 0.3);
        vec2 uv = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;
        vec3 lightDir = normalize(vec3(-2.0, 3.0, 1.5));
        vec3 col = vec3(0.2, 0.22, 0.3);
        vec3 ro = vec3(0.0, 0.0, 5.0);
        vec3 rd = normalize(vec3(uv, -1.8));
        vec2 hit = marchRay(ro, rd);

        if(hit.y != 0.0) {
          vec3 n = normal(ro + rd * hit.x);
          float diff = max(dot(lightDir, n), 0.0);
          float spec = pow(max(dot(reflect(-lightDir, n), -rd), 0.0), 26.0);
          col = sphereCol * (diff + spec*1.8);
        }
        fragColor = vec4(col, 1.0);
      }
    </script>
    <script type="module">
      alert('View source to see the code! A GPU ray marcher in 100 lines of code.')
      import * as twgl from 'https://esm.sh/twgl.js'
      const gl = document.querySelector('canvas').getContext('webgl2')
      const progInfo = twgl.createProgramInfo(gl, ['vs', 'fs'])
      gl.useProgram(progInfo.program)
      twgl.resizeCanvasToDisplaySize(gl.canvas)
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

      const bufferInfo = twgl.createBufferInfoFromArrays(gl, {
        position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
      })
      twgl.setBuffersAndAttributes(gl, progInfo, bufferInfo)

      function render(time) {
        twgl.setUniforms(progInfo, {
          u_time: time * 0.001,
          u_resolution: [gl.canvas.width, gl.canvas.height],
        })
        twgl.drawBufferInfo(gl, bufferInfo)
        requestAnimationFrame(render)
      }
      requestAnimationFrame(render)
    </script>
  </body>
</html>
